# 탐욕법
# 현재 상황에서 지금 당장 좋은 것만 고르는 방법
# 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구
# 그리디 해법은 정당성 분석이 중요
#   - 단순히 가장 좋아 보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는지 검토

# [문제상황] 루트 노드부터 시작하여 거쳐가는 노드 값의 합을 최대로 만들고 싶습니다.
#   - 최적의 해는 무엇인가요?

# 그리디 알고리즘은 최적의 해를 보장할 수 없을 때가 많습니다.
# 코테에서는 탐욕법으로 얻은 해가 최저그이 해가 되는 상황에서, 이를 추론 할 수 있어야 풀리도록 출제한다.


# <문제> 거스름 돈: 문제 설명
# 거스름 돈 500원, 100원, 50원, 10원 무한대
# 손님에게 거슬러주어야 할 돈이 N원일 때, (N은 10의 배수)
# 거슬러 주어야할 동전의 최소 개수를 구하시오.

N = 1260
array = [500, 100, 50, 10]
count = 0
for coin in array:
    count += N // coin
    N %= coin
print(count)

# [정당성 분석]
# 가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문입니다.


# <문제> 1이 될 때까지: 문제 설명
# 수 N이 1이 될 떄까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행하려고 한다.
# 단, 두 번째 연산은 N이 K로 나누어 떨어질 때만 선택할 수 있다.
# 1. N에서 1을 뺀다.
# 2. N을 K로 나눈다.

N = 25
K = 3
count = 0
while N != 1:
    if N % K != 0:
        N -= 1
        count += 1
    else:
        N /= K
        count += 1
print(count)

# [정당성 분석]
# N이 아무리 큰 수여도, K로 계속 나눈다면 기하급수적으로 빠르게 줄일 수 있습니다.
# 다시 말해 K가 2 이상이기만 하면, K로 나누는 것이 1을 빼는 것보다 항상 빠르게 N을 줄일 수 있습니다.
#   - 또한 N은 항상 1에 도달하게 됩니다.(최적의 해 성립)

# 해답
N = 25
K = 3
result = 0
while True:
    # N이 K로 나누어 떨어지는 수가 될 때까지 빼기
    target = (N//K) * K
    result += (N-target)
    N = target
    # N이 K보다 작을 때(더 이상 나눌수 없을 때) 반복문 탈출
    if N < K:
        break
    result += 1
    N //= K
result += (N-1)
print(result)


# <문제> 곱하기 혹은 더하기: 문제 설명
# 각 자리가 숫자로만 이루어진 문자열 S가 주어졌을 때, 왼쪽부터 오른쪽으로 하나씩 모든 숫자를 확인하며
# 숫자 사이에 "x", "+" 연산자를 넣어 결과적으로 만들어질 수 잇는 가장 큰술르 구하는 프로그램을 작성하시오.
# 단, 모든 연산은 왼쪽부터 순서대로 이루어진다.

s = "213"
answer = 0
for i in s:
    i = int(i)
    if i <= 1 or answer <= 1:
        answer += i
    else:
        answer *= i
print(answer)


# <문제> 모험가 길드: 문제 설명
# 한 마을에 모험가 N명이 있습니다. 모험가 길드에서는 N명의 모험가를 대상으로 '공포도'를 측정했는데,
# '공포도'가 높은 모험가는 쉽게 공포를 느껴 위험 상황에서 제대로 대처할 능력이 떨어집니다.
# 모험가 길드장인 동빈이는 모험가 그룹을 안전하게 구성하고자
# 공포도가 X인 모험가는 반드시 X명 이상으로 구성한 모험가 그룹에 참여해야 여행을 떠날수 있도록 규정했습니다.
# 동빈이는 최대 몇 개의 모험가 그룹을 만들 수 있는지 궁금합니다.
# N명의 모험가에 대한 정보가 주어졌을 때, 여행을 떠날 수 있는 그룹 수의 최댓값을 구하는 프로그램을 작성하세요.

n = 5
k = [1,2,3,4,5]

# 이 경우 그룹 1에는 공포도가 1,2,3인 모험가를 한명 씩 넣고, 그룹 2에는 공포도가 2인 남은 두명을 넣게되어
# 총 2개의 그룹을 만들수 있습니다.
# 또한 몇 명의 모험가는 마을에 그대로 남아 있어도 되기 때문에, 모든 모험가를 특정한 그룹에 넣을 필요는 없습니다.

k.sort() # 모험가 공포도 정렬
answer = 0 # 최종 그룹 수
count = 0 # 모집 인원
for i in k:
    count += 1 # 일단 파티 개설부터하고
    if count >= i: # 만약 공포도와 파티인원수가 같다면,
        answer += 1 # 출발
        count = 0 # 다시 새 파티 모집
print(answer)